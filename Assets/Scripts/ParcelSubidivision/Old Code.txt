
    //void FindBoundariesOBB(Parcel parc)
    //{
    //    for (int i = 0; i < parcel.parcelPoints.Count; i++)
    //    {
    //        if (parcel.parcelPoints[i].transform.position.y >= topPosMax.y)
    //        {
    //            topPosMax = parcel.parcelPoints[i].transform.position;
    //        }
    //        if (parcel.parcelPoints[i].transform.position.y <= botPosMax.y)
    //        {
    //            botPosMax = parcel.parcelPoints[i].transform.position;
    //        }
    //        if (parcel.parcelPoints[i].transform.position.x <= leftPosMax.x)
    //        {
    //            leftPosMax = parcel.parcelPoints[i].transform.position;
    //        }
    //        if (parcel.parcelPoints[i].transform.position.x >= rightPosMax.x)
    //        {
    //            rightPosMax = parcel.parcelPoints[i].transform.position;
    //        }
    //    }

    //    maxHeight = Mathf.Abs(topPosMax.y - botPosMax.y);
    //    maxWidth = Mathf.Abs(rightPosMax.x - leftPosMax.x);

    //    obb.topLeftCorner = new Vector3(leftPosMax.x, topPosMax.y, 0) + new Vector3(-1, 1, 0) * 0.1f;
    //    obb.topRightCorner = new Vector3(rightPosMax.x, topPosMax.y, 0) + new Vector3(1, 1, 0) * 0.1f;
    //    obb.botLeftCorner = new Vector3(leftPosMax.x, botPosMax.y, 0) + new Vector3(-1, -1, 0) * 0.1f;
    //    obb.botRightCorner = new Vector3(rightPosMax.x, botPosMax.y, 0) + new Vector3(1, -1, 0) * 0.1f;

    //    obb.UpdateSegments();
    //}

    //// Given three colinear points p, q, r, the function checks if
    //// point q lies on line segment 'pr'
    //bool OnSegment(Vector3 p, Vector3 q, Vector3 r)
    //{
    //    if (q.x <= Mathf.Max(p.x, r.x) && q.x >= Mathf.Min(p.x, r.x) &&
    //        q.y <= Mathf.Max(p.y, r.y) && q.y >= Mathf.Min(p.y, r.y))
    //        return true;

    //    return false;
    //}

    //// To find orientation of ordered triplet (p, q, r).
    //// The function returns following values
    //// 0 --> p, q and r are colinear
    //// 1 --> Clockwise
    //// 2 --> Counterclockwise
    //int Orientation(Vector3 p, Vector3 q, Vector3 r)
    //{
    //    int val = (int)((q.y - p.y) * (r.x - q.x) - (q.x - p.y) * (r.y - q.y));

    //    if (val == 0) return 0; // colinear

    //    //return (val > 0) ? 1 : 2;
    //    if (val > 0)
    //        return 1;
    //    else
    //        return 2;
    //}

    //// Intersection Check -- Points
    //bool DoIntersect(Vector3 p1, Vector3 q1, Vector3 p2, Vector3 q2)
    //{
    //    int o1 = Orientation(p1, q1, p2);
    //    int o2 = Orientation(p1, q1, q2);
    //    int o3 = Orientation(p2, q2, p1);
    //    int o4 = Orientation(p2, q2, q1);

    //    if (o1 != o2 && o3 != o4)
    //        return true;

    //    if (o1 == 0 && OnSegment(p1, p2, q1))
    //        return true;
    //    if (o2 == 0 && OnSegment(p2, p1, q2))
    //        return true;
    //    if (o3 == 0 && OnSegment(p2, p1, q2))
    //        return true;
    //    if (o4 == 0 && OnSegment(p2, q1, q2))
    //        return true;

    //    return false;
    //}

    //// Intersection Check -- Segments 
    //bool DoIntersect(Segment seg1, Segment seg2)
    //{
    //    return DoIntersect(seg1.startPos, seg1.finalPos, seg2.startPos, seg2.finalPos);
    //}

    //// Find Intersection Point -- Points
    //Vector3 FindIntersectionPoint(Vector3 p1, Vector3 q1, Vector3 p2, Vector3 q2)
    //{
    //    float ua = ((q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x)) / ((q2.y - p2.y) * (q1.x - p1.x) - (q2.x - p2.x) * (q2.y - p1.y));
    //    float ub = ((q1.x - p1.x) * (p1.y - p2.y) - (q1.y - p1.y) * (p1.x - p2.x)) / ((q2.y - p2.y) * (q1.x - p1.x) - (q2.x - p2.x) * (q2.y - p1.y));

    //    Vector3 intersectionPoint;
    //    intersectionPoint.x = p1.x + ua * (q1.x - p1.x);
    //    intersectionPoint.y = p1.y + ua * (q1.y - p1.y);
    //    intersectionPoint.z = 0;

    //    return intersectionPoint;
    //}

    //// Find Intersection Point -- Segments
    //Vector3 FindIntersectionPoint(Segment seg1, Segment seg2)
    //{
    //    return FindIntersectionPoint(seg1.startPos, seg1.finalPos, seg2.startPos, seg2.finalPos);
    //}